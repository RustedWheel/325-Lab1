package nz.ac.auckland.concert.server;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import nz.ac.auckland.concert.common.Concert;
import nz.ac.auckland.concert.common.ConcertService;
import nz.ac.auckland.concert.common.FullException;

public class ConcertServiceServant extends UnicastRemoteObject implements ConcertService{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private HashMap<Long,Concert> _concerts;
	private final int _maxConcerts; 
	private int _concertID;


	protected ConcertServiceServant(int maxConcerts) throws RemoteException {
		super();
		_concerts = new HashMap<Long,Concert>();
		_maxConcerts = maxConcerts;
		_concertID = 0;
	}

	/**
	 * Creates and stores a new Concert.
	 * @param concert the new Concert to create. The concert's fields should be 
	 * filled in except for the id field, whose value is generated by the service.
	 * @return a copy of the new Concert, with its id field populated.
	 * @throws RemoteException
	 */
	public synchronized  Concert createConcert(Concert concert) throws FullException, RemoteException {
		
		int numberOfConcerts = _concerts.size();

		if(numberOfConcerts == _maxConcerts) {
			throw new FullException();
		}
		
		Long uid = new Long(_concertID++);
		Concert newConcert = new Concert(uid, concert.getTitle(),concert.getDate());
		_concerts.put(uid, newConcert);
		
		return newConcert;
	}

	/**
	 * Retrieves a Concert based on a specified id. 
	 * @param id the id of the requested Concert.
	 * @return The matching Concert object, or null if there is no match. 
	 * @throws RemoteException
	 */
	public synchronized Concert getConcert(Long id) throws RemoteException {
		
		if(_concerts.containsKey(id)){
			return _concerts.get(id);
		}
		
		return null;
	}

	/**
	 * Updates an existing Concert.
	 * @param concert the Concert to update.
	 * @return true if the Concert exists, false otherwise. Where false is
	 * returned the state of the service is not changed (i.e. the Concert isn't
	 * stored).
	 * @throws RemoteException
	 */
	public synchronized boolean updateConcert(Concert newConcert) throws RemoteException {
		
		if(_concerts.containsKey(newConcert.getId())){
			
			_concerts.replace(newConcert.getId(), newConcert);
			
			return true;
		}
		
		return false;
	}

	/**
	 * Deletes a Concert with a specified id.
	 * @param id the unique id of the Concert to delete.
	 * @return true if the Concert is found and deleted, false otherwise.
	 * @throws RemoteException
	 */
	public synchronized boolean deleteConcert(Long id) throws RemoteException {
		
		if(_concerts.containsKey(id)){
			_concerts.remove(id);
			
			if(!_concerts.containsKey(id)){
				return true;
			}
		}
		
		return false;
	}

	/**
	 * Returns all Concerts known to the service.
	 * @return A List of Concerts.
	 * @throws RemoteException
	 */
	public synchronized List<Concert> getAllConcerts() throws RemoteException {
		List<Concert> Concerts = new ArrayList<Concert>(_concerts.values());
		return Concerts;
	}

	/**
	 * removes all Concerts stored b the service.
	 * @throws RemoteException
	 */
	public synchronized void clear() throws RemoteException {
		_concerts.clear();
	}

}
